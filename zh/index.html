<!doctype html>
<html lang="zh-CN" itemscope itemtype="http://schema.org/CreativeWork">
<head>

  <title>How to lose weight (in the browser)</title>

  <!-- Metatags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="权威的前端性能指南">
  <meta name="keywords" content="front-end, web performance, cache, compress, minify, combine">

  <!-- Schema.org -->
  <meta itemprop="name" content="How to lose weight (in the browser)">
  <meta itemprop="url" content="https://browserdiet.com/zh">
  <meta itemprop="image" content="https://browserdiet.com/assets/img/share.jpg">
  <meta itemprop="description" content="权威的前端性能指南">

  <!-- Style -->
  <link rel="stylesheet" href="https://browserdiet.com/assets/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css">

  <!-- Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans|Pacifico">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="https://browserdiet.com/assets/img/favicon.ico">

  <!-- Languages -->
  <link rel="alternate" hreflang="cs" href="https://browserdiet.com/cs/">
  <link rel="alternate" hreflang="en" href="https://browserdiet.com/">
  <link rel="alternate" hreflang="es" href="https://browserdiet.com/es/">
  <link rel="alternate" hreflang="fr" href="https://browserdiet.com/fr/">
  <link rel="alternate" hreflang="jp" href="https://browserdiet.com/jp/">
  <link rel="alternate" hreflang="pl" href="https://browserdiet.com/pl/">
  <link rel="alternate" hreflang="pt" href="https://browserdiet.com/pt/">
  <link rel="alternate" hreflang="zh" href="https://browserdiet.com/zh/">
</head>

<body class="zh">

  <div id="header">

  <div id="topbar" class="subtitle">
    <div class="center">
      <h3>权威的前端性能指南</h3>

      <select id="language-picker">
        <option value="cs" >Česky</option>
        <option value="en" >English</option>
        <option value="es" >Español</option>
        <option value="fr" >Français</option>
        <option value="jp" >日本語</option>
        <option value="pl" >Polski</option>
        <option value="pt" >Português</option>
        <option value="zh" selected>中国的</option>
      </select>
    </div>
  </div>

  <a class="github-fork-ribbon" href="https://github.com/zenorocha/browser-diet" title="Fork me on GitHub">Fork me on GitHub</a>

  <div class="center">
    <div class="intro">
      <hgroup class="intro-titles">
        <h1>How to lose <span>weight</span></h1><h2>in the browser</h2>
      </hgroup>

      <div class="superman">
        <img class="superman-geek" src="https://browserdiet.com/assets/img/superman.png" alt="Superman">
        <img class="superman-rays" src="https://browserdiet.com/assets/img/rays.png" alt="">
      </div>
    </div>

  </div>

  <div id="menu">
    <ul class="center">
      <li><a href="#html">HTML</a></li>
      <li><a href="#css">CSS</a></li>
      <li><a href="#js">JavaScript</a></li>
      <li><a href="#jquery">jQuery</a></li>
      <li><a href="#images">Images</a></li>
      <li><a href="#bonus">Bonus</a></li>
    </ul>
  </div>

</div>

<div id="content">
  <div class="center">

    
        <div class="article">
          <div class="img-left">
  <img id="geek-17" class="icos-geek" src="https://browserdiet.com/assets/img/17.png" alt="Geek #17" width="199" height="275" />
</div>

<p>一大群为大型站点工作的专家们，能够一起建立一份权威的前端性能指南吗？</p>
<p><a href="http://www.brizabueno.com/">Briza Bueno</a> <em>(Americanas.com)</em>, <a href="https://github.com/davidsonfellipe">Davidson Fellipe</a> <em>(Globo.com)</em>, <a href="https://github.com/keppelen">Giovanni Keppelen</a> <em>(ex-Peixe Urbano)</em>, <a href="https://github.com/jaydson">Jaydson Gomes</a> <em>(Terra)</em>, <a href="https://github.com/marcelduran">Marcel Duran</a> <em>(Twitter)</em>, <a href="https://github.com/miketaylr">Mike Taylor</a> <em>(Opera)</em>, <a href="https://github.com/mangini">Renato Mangini</a> <em>(Google)</em>, and <a href="http://sergiolopes.org">Sérgio Lopes</a> <em>(Caelum)</em>有没有可能一起出一份权威的参考呢?</p>
<p>这正是我们所做的！我们会引导你创造更快的网站。</p>
<p class="project-leader">&mdash; <a href="http://zenorocha.com/">Zeno Rocha</a>, project lead.</p>
        </div>
    
        <div class="article">
          <h1 id="performance-matters">
  <a class="tip-title" href="#performance-matters">性能真的很重要吗？</a>
  <a title="Link" class="anchor" href="#performance-matters">∞</a>
</h1>

<div class="line">
  <span class="order">??</span>
  <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/intro/en/performance-matters.html">✎</a>
</div>

<p>你当然知道它很重要。所以为什么我们还要做出速度很慢的网站，给用户一个糟糕的体验呢？这是一份由社区驱动的实用指南，它能帮助你让你的网站更快。我们没有必要再浪费时间来列举<a href="https://github.com/zenorocha/browser-diet/wiki/Impact-of-performance">大量需要优化性能的场景</a>了，让我们直接进入重点！</p>
        </div>
    

    <h2 id="html" class="topics"><span>HTML</span></h2>



  <div class="article" id="article-avoid-inline">
    <h1 id="avoid-inline">
      <a class="tip-title" href="#avoid-inline">避免 内联式/嵌入式 代码</a>
      <a title="Link" class="anchor" href="#avoid-inline">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/zh/avoid-inline.html.md">✎</a>
    </div>
    
    <p>你可以通过三种方式在HTML页面中引入CSS或Javascript代码:</p>
<p><strong>1) 内联式:</strong> 在HTML标签的<code>style</code>属性中定义样式，在<code>onclick</code>这样的属性中定义Javascript代码;</p>
<p><strong>2) 嵌入式:</strong> 在页面中使用<code>&lt;style&gt;</code>标签定义样式，使用<code>&lt;script&gt;</code>标签定义Javascript代码;</p>
<p><strong>3) 引用外部文件:</strong> 在<code>&lt;link&gt;</code>标签中定义<code>href</code>属性引用CSS文件，在<code>&lt;script&gt;</code>标签中定义<code>src</code>属性引入Javascript文件.</p>
<p>尽管前两种方式减少了HTTP请求数，可是实际上却增加了HTML文档的体积。不过，当你的页面中的CSS或者Javascript代码足够少，反而是开启一个HTTP请求的花费要更大时，采用这两种方式却是最有用的。因此，你需要测试评估这种方式是否真的提升了速度。同时也要考虑到你的页面的目标和它的受众：如果你期望人们只会访问它一次，例如对一些临时活动来说，你决不会期望有回访客出现，那么使用内联式/嵌入式代码能够帮助减少HTTP请求数。</p>
<p><em>&gt; 尽量避免在你的HTML中手工编写CSS/JS（首选的方法是通过工具实现这个过程的自动化）。</em></p>
<p>第三种方式不仅使你的代码更有序，而且使得浏览器能够缓存它。这种方式在大多数的情况下都是首选，特别是一些大文件和多页面的情况。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-avoid-inlineembedded-code">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#avoid-inlineembedded-code">参考</a></em></p>

  </div>



  <div class="article" id="article-css-on-top-js-on-bottom">
    <h1 id="css-on-top-js-on-bottom">
      <a class="tip-title" href="#css-on-top-js-on-bottom">样式在上，脚本在下</a>
      <a title="Link" class="anchor" href="#css-on-top-js-on-bottom">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/zh/css-on-top-js-on-bottom.html.md">✎</a>
    </div>
    
    <p>当我们把样式放在<code>&lt;head&gt;</code>标签中时，浏览器在渲染页面时就能尽早的知道每个标签的样式，我们的用户就会感觉这个页面加载的很快。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Browser Diet<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- CSS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"style.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
</code></pre>
<p>但是如果我们将样式放在页面的结尾，浏览器在渲染页面时就无法知道每个标签的样式，直到CSS被下载执行后。</p>
<div class="img-right">
  <img id="geek-32" class="icos-geek" src="https://browserdiet.com/assets/img/32.png" alt="Geek #32" width="139" height="275" />
</div>

<p>另一方面，对于Javascript来说，因为它在执行过程中会阻塞页面的渲染，所以我们要把它放在页面的结尾。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- JS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"script.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
</code></pre>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#styles-up-top-scripts-down-bottom">参考</a></em></p>

  </div>



  <div class="article" id="article-async">
    <h1 id="async">
      <a class="tip-title" href="#async">尝试async</a>
      <a title="Link" class="anchor" href="#async">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/zh/async.html.md">✎</a>
    </div>
    
    <p>为了解释这个属性对于性能优化是多么有用，我们应该先明白，当不使用它时会发生什么。</p>
<div class="img-left">
  <img id="geek-20" class="icos-geek" src="https://browserdiet.com/assets/img/20.png" alt="Geek #20" width="118" height="275" />
</div>

<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"example.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>使用上面这种方式时，页面会在这个脚本文件被完全下载、解析、执行完后才去渲染之后的HTML，在这之前会一直处于阻塞状态。这就意味着会增加你的页面的加载时间。有时这种行为是我们希望的，而大多数时候则不想要。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">async</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"example.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>使用上面这种方式时，脚本的加载是异步的，不会影响到这之后的页面解析。脚本会在下载完之后立即执行。需要注意的是，如果有多个使用这种方式异步加载的脚本，他们是没有特定的执行顺序的。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#try-out-async">参考</a></em></p>

  </div>




    <h2 id="css" class="topics"><span>CSS</span></h2>



  <div class="article" id="article-minify-css">
    <h1 id="minify-css">
      <a class="tip-title" href="#minify-css">压缩你的样式表</a>
      <a title="Link" class="anchor" href="#minify-css">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/zh/minify-css.html.md">✎</a>
    </div>
    
    <p>为了保持代码的可读性，最好的方法是在代码中添加注释和使用缩进：</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-class">.center</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">960px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span> auto</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-comment">/* --- Structure --- */</span>

<span class="hljs-class">.intro</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">100px</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>但是对于浏览器来说，这些都是不重要的。正因为如此，通过自动化工具压缩你的CSS是非常有用的。</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-class">.center</span><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">960px</span></span></span>;<span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">0</span> auto</span></span></span>}<span class="hljs-class">.intro</span><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">100px</span></span></span>;<span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">relative</span></span></span>}
</code></pre>
<p>这样做能够减小文件的大小，从而得到更快的下载、解析和执行。</p>
<p>对于使用预处理器例如 <a href="http://sass-lang.com/">Sass</a>, <a href="http://lesscss.org/">Less</a>, and <a href="http://learnboost.github.com/stylus/">Stylus</a>, 你可以通过配置缩小编译输出的CSS代码。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-minify-your-stylesheets">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minify-your-stylesheets">参考</a></em></p>

  </div>



  <div class="article" id="article-combine-css">
    <h1 id="combine-css">
      <a class="tip-title" href="#combine-css">合并多个CSS文件</a>
      <a title="Link" class="anchor" href="#combine-css">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/zh/combine-css.html.md">✎</a>
    </div>
    
    <p>对于样式的组织和维护，另一个好方法是将他们模块化。</p>
<div class="img-right">
  <img id="geek-9" class="icos-geek" src="https://browserdiet.com/assets/img/9.png" alt="Geek #9" width="122" height="275" />
</div>

<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"structure.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"banner.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"layout.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"component.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"plugin.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
</code></pre>
<p>然而，这样每个文件就是一个HTTP请求（我们都知道，浏览器的并行下载数是有限的）。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"main.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
</code></pre>
<p>所以，合并你的CSS文件。文件数量的减少就会带来请求数量的减少和更快的页面加载速度。</p>
<p>Want to have the best of both worlds? Automate this process through a build tool.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-combining-multiple-css-files">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#combining-multiple-css-files">参考</a></em></p>

  </div>



  <div class="article" id="article-prefer-link-over-import">
    <h1 id="prefer-link-over-import">
      <a class="tip-title" href="#prefer-link-over-import">使用 &lt;link&gt; 标签而不是 @import</a>
      <a title="Link" class="anchor" href="#prefer-link-over-import">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/zh/prefer-link-over-import.html.md">✎</a>
    </div>
    
    <p>有两种方式可以引入一个外部的样式表：通过 <code>&lt;link&gt;</code> 标签：</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"style.css"</span>&gt;</span>
</code></pre>
<p>或者通过 <code>@import</code> 指令 (使用在一个外部样式表中或者页面内嵌的 <code>&lt;style&gt;</code> 标签中):</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-function">url</span>(<span class="hljs-string">'style.css'</span>)</span>;
</code></pre>
<p>当你在一个外部样式表中使用第二种方式时，浏览器无法通过并行下载的方式下载这个资源，这样就会导致其他资源的下载被阻塞。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#prefer--over-import">参考</a></em></p>

  </div>




    <h2 id="js" class="topics"><span>JavaScript</span></h2>



  <div class="article" id="article-3rd-party-async">
    <h1 id="3rd-party-async">
      <a class="tip-title" href="#3rd-party-async">异步加载第三方内容</a>
      <a title="Link" class="anchor" href="#3rd-party-async">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/3rd-party-async.html.md">✎</a>
    </div>
    
    <p>嵌入一个Youtube视频或者一个like/tweet按钮，有人没有加载过这样的第三方内容吗？</p>
<div class="img-right">
  <img id="geek-46" class="icos-geek" src="https://browserdiet.com/assets/img/46.png" alt="Geek #46" width="158" height="275" />
</div>

<p>问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时dowan掉或者是被用户或者其公司的防火墙阻止。</p>
<p>为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码 (或者使用 <em><a href="https://www.facebook.com/note.php?note_id=10151176218703920">Friendly iFrames</a></em>).</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>),
    scripts = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>];
script.async = <span class="hljs-literal">true</span>;
script.src = url;
scripts.parentNode.insertBefore(script, scripts);
</code></pre>
<p>另外，如果你想加载多个第三方插件，你可以使用<a href="https://gist.github.com/zenorocha/5161860">这个代码</a>来实现异步的加载。</p>
<p><em>&gt; <a href="http://www.webpagetest.org/video/view.php?id=111011_4e0708d3caa23b21a798cc01d0fdb7882a735a7d">视频</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#load-3rd-party-content-asynchronously">参考</a></em></p>

  </div>



  <div class="article" id="article-cache-array-lengths">
    <h1 id="cache-array-lengths">
      <a class="tip-title" href="#cache-array-lengths">缓存数组长度</a>
      <a title="Link" class="anchor" href="#cache-array-lengths">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/cache-array-lengths.html.md">✎</a>
    </div>
    
    <p>循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。</p>
<p>要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>),
    len, i;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
  <span class="hljs-comment">// Bad - size needs to be recalculated 1000 times</span>
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
  <span class="hljs-comment">// Good - size is calculated only 1 time and then stored</span>
}
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-cache-array-length/10/">&gt; Results on JSPerf</a></em></p>
<p><strong>&gt; 注解:</strong> <em>虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器</em></p>
<p>在迭代<code>document.getElementsByTagName(&#39;a&#39;)</code>等类似方法生成的HTML节点数组（<em>NodeList</em>）时，缓存数组长度尤为关键。这些集合通常被认为是“活的”，也就是说，当他们所对应的元素发生变化时，他们会被自动更新。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> links = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'a'</span>),
    len, i;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; links.length; i++) {
  <span class="hljs-comment">// Bad - each iteration the list of links will be recalculated to see if there was a change</span>
}

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = links.length; i &lt; len; i++) {
  <span class="hljs-comment">// Good - the list size is first obtained and stored, then compared each iteration</span>
}

<span class="hljs-comment">// Terrible: infinite loop example</span>
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; links.length; i++) {
  <span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'a'</span>));
  <span class="hljs-comment">// each iteration the list of links increases, never satisfying the termination condition of the loop</span>
  <span class="hljs-comment">// this would not happen if the size of the list was stored and used as a condition</span>
}
</code></pre>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#cache-array-lengths">参考</a></em></p>

  </div>



  <div class="article" id="article-documentwrite">
    <h1 id="documentwrite">
      <a class="tip-title" href="#documentwrite">避免使用document.write</a>
      <a title="Link" class="anchor" href="#documentwrite">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/documentwrite.html.md">✎</a>
    </div>
    
    <p>The use of <code>document.write</code> causes a dependency to the page on its return to be fully loaded.</p>
<p>这个（坏）方法已经被开发者抛弃了很多年, 但是在某些情况下仍然是需要的，例如在一些Javascript文件的同步回退中。</p>
<p>举例来说，如果发现Google的CDN没有响应，<a href="https://github.com/h5bp/html5-boilerplate/">HTML5 Boilerplate</a>则会通过这个方法来调用本地的jQuery库。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">window</span>.jQuery || <span class="hljs-built_in">document</span>.write(<span class="hljs-string">'&lt;script src="js/vendor/jquery-1.9.0.min.js"&gt;&lt;\/script&gt;'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p><strong>&gt; 注意:</strong> <em>如果在<code>window.onload</code>事件中或之后执行<code>document.write</code>方法，会将当前页面替换掉。</em></p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">'&lt;span&gt;bar&lt;/span&gt;'</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>这段代码执行后的结果是页面中只会呈现出<em>bar</em>字符，而不是期望的出现<em>foobar</em>。在<code>window.onload</code>事件之后执行也是同样的结果。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">'&lt;span&gt;bar&lt;/span&gt;'</span>);
  }, <span class="hljs-number">1000</span>);
  <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ...</span>
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>这段代码执行的结果和上一段代码的结果相同。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#avoid-documentwrite">参考</a></em></p>

  </div>



  <div class="article" id="article-repaints-and-reflows">
    <h1 id="repaints-and-reflows">
      <a class="tip-title" href="#repaints-and-reflows">最小化重绘和回流</a>
      <a title="Link" class="anchor" href="#repaints-and-reflows">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/repaints-and-reflows.html.md">✎</a>
    </div>
    
    <p>当有任何属性或元素发生改变时，都会引起DOM元素的重绘和回流。</p>
<p>当一个元素的布局不变，外观发生改变时，就会引起重绘。Nicole Sullivan描述这个就像是样式的改变，例如改变<code>background-color</code>。</p>
<p>回流的代价是最高的，当改变一个页面的布局时就会发生回流，例如改变一个元素的宽。</p>
<p>毫无疑问，应当避免过多的重绘和回流，所以，对于下面的代码：</p>
<div class="img-right">
  <img id="geek-55" class="icos-geek" src="https://browserdiet.com/assets/img/55.png" alt="Geek #55" width="163" height="275" />
</div>

<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"to-measure"</span>),
    lis = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'li'</span>),
    i, len;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = div.offsetWidth + <span class="hljs-string">'px'</span>;
}
</code></pre>
<p>应当变为：</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"to-measure"</span>),
    lis = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'li'</span>),
    widthToSet = div.offsetWidth,
    i, len;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = widthToSet + <span class="hljs-string">'px'</span>;
}
</code></pre>
<p>当你设置<code>style.width</code>时，浏览器需要重新计算布局。通常，浏览器暂时是不需要知道改变了元素的样式的，直到它需要更新屏幕时，正因为如此，改变多个元素的样式只会产生一次回流。然而，在第一个例子中，我们每次请求<code>offsetWidth</code>时，都会使浏览器重新计算布局。</p>
<p>如果需要得到页面中的布局数据，那么请参照第二个例子，将这些操作放在任何会改变布局的设置前。</p>
<p><em>&gt; <a href="http://jsbin.com/aqavin/2/quiet">示例</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minimize-repaints-and-reflows">参考</a></em></p>

  </div>



  <div class="article" id="article-dont-touch-dom">
    <h1 id="dont-touch-dom">
      <a class="tip-title" href="#dont-touch-dom">避免不必要的DOM操作</a>
      <a title="Link" class="anchor" href="#dont-touch-dom">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/dont-touch-dom.html.md">✎</a>
    </div>
    
    <p>当你获得DOM而又什么都不做时，这简直就是在杀死宝贵的生命。</p>
<p>说真的，浏览器遍历DOM元素的代价是昂贵的。虽然Javascript引擎变得越来越强大，越来越快速，但是还是应该最大化的优化查询DOM树的操作。</p>
<p>最简单的替代方案就是，当一个元素会出现多次时，将它保存在一个变量中，这样的话你就没必要每次都去查询DOM树了。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// really bad!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myList"</span>).innerHTML += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}
</code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// much better :)</span>
<span class="hljs-keyword">var</span> myList = <span class="hljs-string">""</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  myList += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}

<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myList"</span>).innerHTML = myList;
</code></pre>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// much *much* better :)</span>
<span class="hljs-keyword">var</span> myListHTML = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myList"</span>).innerHTML;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  myListHTML += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}
</code></pre>
<p><em>&gt; <a href="http://jsperf.com/browser-diet-dom-manipulation/11">Results on JSPerf</a></em></p>

  </div>



  <div class="article" id="article-minify-js">
    <h1 id="minify-js">
      <a class="tip-title" href="#minify-js">压缩你的脚本</a>
      <a title="Link" class="anchor" href="#minify-js">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/minify-js.html.md">✎</a>
    </div>
    
    <p>和CSS一样，为了保持代码的可读性，最好的方法是在代码中添加注释和使用缩进：</p>
<pre class="highlight"><code class="hljs javascript">BrowserDiet.app = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{

  <span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">return</span> {
    bar: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">// do something</span>
    }
  };

};
</code></pre>
<p>但是对于浏览器来说，这些都是不重要的。正因为如此，请记住用自动化工具压缩你的Javascript代码。</p>
<pre class="highlight"><code class="hljs javascript">BrowserDiet.app=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{<span class="hljs-keyword">var</span> a=!<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>{bar:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{}}}
</code></pre>
<p>这样做能够减小文件的大小，从而得到更快的下载、解析和执行。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-minify-your-script">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minify-your-script">参考</a></em></p>

  </div>



  <div class="article" id="article-combine-js">
    <h1 id="combine-js">
      <a class="tip-title" href="#combine-js">将多个JS文件合并</a>
      <a title="Link" class="anchor" href="#combine-js">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/zh/combine-js.html.md">✎</a>
    </div>
    
    <p>对于脚本的组织和维护，另一个好方法是将他们模块化。</p>
<div class="img-right">
  <img id="geek-47" class="icos-geek" src="https://browserdiet.com/assets/img/47.png" alt="Geek #47" width="174" height="275" />
</div>

<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"navbar.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"component.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"page.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"framework.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"plugin.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>然而，这样每个文件就是一个HTTP请求（我们都知道，浏览器的并行下载数是有限的）。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"main.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>所以，合并你的JS文件。文件数量的减少就会带来请求数量的减少和更快的页面加载速度。</p>
<p>想要两全其美？通过构建工具自动化这个过程吧。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-combine-multiple-js-files-into-one">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#combine-multiple-js-files-into-one">参考</a></em></p>

  </div>




    <h2 id="jquery" class="topics"><span>jQuery</span></h2>



  <div class="article" id="article-latest-version">
    <h1 id="latest-version">
      <a class="tip-title" href="#latest-version">总是使用最新版本jQuery</a>
      <a title="Link" class="anchor" href="#latest-version">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/zh/latest-version.html.md">✎</a>
    </div>
    
    <p>jQuery的核心团队通过改进代码的可读性、加入新的函数和优化现有的算法，不停地改进着这个库。</p>
<div class="img-right">
  <img id="geek-36" class="icos-geek" src="https://browserdiet.com/assets/img/36.png" alt="Geek #36" width="144" height="275" />
</div>

<p>正因为如此，请总是使用最新版本的jQuery。访问下面的地址，你总会得到最新的jQuery。</p>
<pre class="highlight"><code class="hljs xml">http://code.jquery.com/jquery-latest.js
</code></pre>
<p>但是 <em>绝对</em> 不要在一个<code>&lt;script&gt;</code>标签中引用这个地址，因为通过这个地址得到的总是最新的版本代码，所以如果你没有测试过，可能会造成一些问题。正确的做法是，你需要指明引用的jQuery的版本。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>英明的<a href="/img/new-is-always-better.gif">Barney Stinson</a>说过, <em>&quot;New is always better&quot;</em> :P</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#always-use-the-latest-version-of-jquery">参考</a></em></p>

  </div>



  <div class="article" id="article-selectors">
    <h1 id="selectors">
      <a class="tip-title" href="#selectors">Selectors</a>
      <a title="Link" class="anchor" href="#selectors">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/zh/selectors.html.md">✎</a>
    </div>
    
    <p>在使用jQuery时，选择器也是一个重要的问题。有许多方法可以从DOM中选取元素，但这不意味着这些方法有相同的性能，你可以用classes、IDs或者find()、children()等方法选取元素。</p>
<p>在这些方法中，使用ID选择器是最快的，因为它是原生DOM操作。</p>
<pre class="highlight"><code class="hljs javascript">$(<span class="hljs-string">"#foo"</span>);
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-jquery-selectors">&gt; Results on JSPerf</a></em></p>

  </div>



  <div class="article" id="article-use-for-instead-of-each">
    <h1 id="use-for-instead-of-each">
      <a class="tip-title" href="#use-for-instead-of-each">使用for，而不是each</a>
      <a title="Link" class="anchor" href="#use-for-instead-of-each">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/zh/use-for-instead-of-each.html.md">✎</a>
    </div>
    
    <p>原生Javascript中的函数执行几乎总是要比jQuery快一些。正因为如此，请使用Javascript的<code>for</code>循环，不要使用<code>jQuery.each</code>方法。</p>
<p>但是请注意，虽然<code>for in</code>是原生的，可是在许多情况下，它的性能要比<code>jQuery.each</code>差一些。</p>
<p>在<code>for</code>循环迭代时，请记得缓存集合的长度。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = a.length; i &lt; len; i++ ) {
    e = a[i];
}
</code></pre>
<p>在社区中，关于<code>while</code>和<code>for</code>循环的反向使用问题是一个热门话题，而这经常被认为是最快的迭代方式。然而实际上，这通常只是为了防止循环不够清晰。</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-comment">// 逆转 while</span>
<span class="hljs-keyword">while</span> ( i-- ) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 逆转 for</span>
<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = array.length; i--; ) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><em>&gt; <a href="http://jsperf.com/browser-diet-jquery-each-vs-for-loop">Results on JSPerf</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#use-for-instead-of-each">参考</a></em></p>

  </div>



  <div class="article" id="article-dont-use-jquery">
    <h1 id="dont-use-jquery">
      <a class="tip-title" href="#dont-use-jquery">不要使用jQuery...</a>
      <a title="Link" class="anchor" href="#dont-use-jquery">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/zh/dont-use-jquery.html.md">✎</a>
    </div>
    
    <p>...除非它是必需的。 :)</p>
<p>有时vanilla JavaScript要比jQuery简单一些。</p>
<div class="img-right">
  <img id="geek-6" class="icos-geek" src="https://browserdiet.com/assets/img/6.png" alt="Geek #6" width="156" height="275" />
</div>

<p>使用<code>attr()</code>方法来查询ID：</p>
<pre class="highlight"><code class="hljs javascript">$(<span class="hljs-string">'a'</span>).on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">console</span>.log( $(<span class="hljs-keyword">this</span>).attr(<span class="hljs-string">'id'</span>) );
});
</code></pre>
<p>如果你能通过<code>this</code>的本身属性获得，还需要上面的方法吗？</p>
<pre class="highlight"><code class="hljs javascript">$(<span class="hljs-string">'a'</span>).on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">console</span>.log( <span class="hljs-keyword">this</span>.id );
});
</code></pre>
<p>而且这样还更快。</p>
<p><em>&gt; <a href="http://jsperf.com/browser-diet-this-attr-id-vs-this-id">Results on JSPerf</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#dont-use-jquery">参考</a></em></p>

  </div>




    <h2 id="images" class="topics"><span>Images</span></h2>



  <div class="article" id="article-sprites">
    <h1 id="sprites">
      <a class="tip-title" href="#sprites">使用CSS Sprites</a>
      <a title="Link" class="anchor" href="#sprites">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/zh/sprites.html.md">✎</a>
    </div>
    
    <p>这个技术就是将各种图片整合到一个文件中去。</p>
<p><img id="img-sprite" src="https://browserdiet.com/assets/img/sprite-example.jpg" alt="CSS Sprite Example"></p>
<p>然后通过CSS去定位它们。</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(<span class="hljs-string">'mySprite.png'</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-position</span>:<span class="hljs-value"> -<span class="hljs-number">10px</span> -<span class="hljs-number">10px</span></span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-class">.icon-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(<span class="hljs-string">'mySprite.png'</span>)</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-position</span>:<span class="hljs-value"> -<span class="hljs-number">5px</span> -<span class="hljs-number">5px</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>这么做的结果就是，减少了HTTP请求数，避免延迟页面上的其他资源。</p>
<p>在使用<em>sprite</em>时，应当避免在每个图片之间的空隙过大。这个虽然不会影响到文件的大小，但是会影响到内存的消耗。</p>
<p>尽管每个人都知道sprites，但是这种技术并没有被广泛使用&mdash;或许是由于开发者没有使用自动化工具去生成。 我们着重介绍了一些工具，或许可以帮到你。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-use-css-sprites">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#use-css-sprites">参考</a></em></p>

  </div>



  <div class="article" id="article-data-uri">
    <h1 id="data-uri">
      <a class="tip-title" href="#data-uri">Data URI</a>
      <a title="Link" class="anchor" href="#data-uri">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/zh/data-uri.html.md">✎</a>
    </div>
    
    <p>这种技术是CSS Sprites的替代方法。</p>
<p><a href="http://en.wikipedia.org/wiki/Data_URI_scheme">Data-URI</a>是指使用图片的数据代替通常使用的图片URI，在下面的例子中，我们就使用它减少了HTTP请求数。</p>
<p>使用前:</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(<span class="hljs-string">'foo.png'</span>)</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>使用后:</p>
<pre class="highlight"><code class="hljs css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url</span>(<span class="hljs-string">'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII%3D'</span>)</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>所有的现代浏览器和IE8及以上版本的IE都支持这个方法，图片需要使用base64方法编码。</p>
<p>这种技术和CSS Sprites技术都是可以使用构建工具得到的。使用构建工具的好处是不用手工去进行图片的拼合替换，在开发时使用单独的文件就可以。</p>
<p>然而坏处是，随着你的HTML/CSS文件的增大增多，你必须考虑你可能会有一个非常大的图片。如果你在HTTP请求中没有使用gzip技术压缩你的HTML/CSS，那么我们不推荐使用这种方法，因为减少HTTP请求数得到的大文件对于速度来说可能带来相反的结果。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-data-uri">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#data-uri">参考</a></em></p>

  </div>



  <div class="article" id="article-scale">
    <h1 id="scale">
      <a class="tip-title" href="#scale">不要在 &lt;img&gt; 标签中调整图像</a>
      <a title="Link" class="anchor" href="#scale">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/zh/scale.html.md">✎</a>
    </div>
    
    <p>总是在<code>img</code>标签中设置<code>width</code>和<code>height</code>属性。这样可以防止渲染过程中的重绘和回流。</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">width</span>=<span class="hljs-value">"100"</span> <span class="hljs-attribute">height</span>=<span class="hljs-value">"100"</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"logo.jpg"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"Logo"</span>&gt;</span>
</code></pre>
<p>知道这个之后，一个开发者将一个<em>700x700px</em>的图像设置为<em>50x50px</em>来显示。</p>
<p>但是这个开发者不知道的是，大量的没有用的数据也发送到了客户端。</p>
<p>所以请记住：你可以在标签中定义一个图片的寬高，但不意味着你应该通过这么做来(等比)缩放大图。</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#dont-rescale-images-in-markup">参考</a></em></p>

  </div>



  <div class="article" id="article-optimize">
    <h1 id="optimize">
      <a class="tip-title" href="#optimize">优化你的图片。</a>
      <a title="Link" class="anchor" href="#optimize">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/zh/optimize.html.md">✎</a>
    </div>
    
    <p>图片文件中包含许多对于Web来说没有用的东西。举例来说，一个JPEG图片中可能包含一些<em>Exif</em>元数据（数据，相机型号，坐标等等）。一个PNG图片会包含有关颜色，元数据的信息，有时甚至还包含一个缩略图。这些只会增加文件的大小，而对于浏览器来说却毫无用处。</p>
<p>有很多工具能够帮你从图片中去除这些信息，并且不会降低图片的质量。我们把这个称做<em>无损</em>压缩。</p>
<p>另一种优化图片的方式是，以图片质量为代价进行压缩。我们称之为<em>有损</em>压缩。举例来说，当你导出一个JPEG图片时，你可以选择导出的图片质量（从0到100）。考虑到性能，总是选择可接受范围内的最低值。在PNG图片中，另一个常见的有损技术是减少颜色数量，或者将PNG-24格式转换为PNG-8格式。</p>
<p>为了提升用户的体验，你还应该将你的JPEG文件转换为渐进式的。现在大多数的浏览器都支持渐进式JPEG文件，并且这种格式的文件创建简单，没有明显的性能损失问题。页面中的这种格式的图片能够更快的展现(<a href="http://www.patrickmeenan.com/progressive/view.php?img=http://farm2.staticflickr.com/1434/1002257937_021cb46a33_o.jpg">see demo</a>).</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#wiki-optimize-your-images">小工具</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#optimize-your-images">参考</a></em></p>

  </div>




    <h2 id="bonus" class="topics"><span>Bonus</span></h2>



  <div class="article" id="article-tools">
    <h1 id="tools">
      <a class="tip-title" href="#tools">诊断工具：你最好的朋友</a>
      <a title="Link" class="anchor" href="#tools">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/bonus/zh/tools.html.md">✎</a>
    </div>
    
    <div class="img-left">
  <img id="geek-43" class="icos-geek" src="https://browserdiet.com/assets/img/43.png" alt="Geek #43" width="157" height="275" />
</div>

<p>如果你想知道这个世界上的Web性能，那么你一定要给你的浏览器安装<a href="http://yslow.org/">YSlow</a> 从现在起，它们将是你最好的朋友。</p>
<p>或者你可以选择使用在线工具，访问<a href="http://www.webpagetest.org/">WebPageTest</a>, <a href="http://httparchive.org/">HTTP Archive</a>或者<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed</a>。</p>
<p>不管是哪种方式，都可以对你的网站的性能进行分析，并且给出分析报告，还可以对潜在的问题给出建议。</p>

  </div>



  <div class="article" id="article-bye">
    <h1 id="bye">
      <a class="tip-title" href="#bye">That's it for today!</a>
      <a title="Link" class="anchor" href="#bye">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/bonus/zh/bye.html.md">✎</a>
    </div>
    
    <div class="img-right">
  <img id="geek-31" src="https://browserdiet.com/assets/img/31.png" alt="Geek #31" width="162" height="275" />
</div>

<p>我们希望，在阅读了这篇指南之后，你就能够对你的网站进行瘦身了。:)</p>
<p>同时请记住，和生活中其他事情一样，<a href="http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html">没有所谓的银弹</a>。虽然优化你的应用的性能是值得的，但是这不应该作为你决定开发策略的唯一基础&mdash;偶尔你需要平衡下成本和收益。</p>
<p>想要了解更多？查看<a href="https://github.com/zenorocha/browser-diet/wiki/References">参考</a>，这篇指南就是依据它写出来的。</p>
<p>有什么建议吗？你可以给<a href="http://twitter.com/browserdiet/">@BrowserDiet</a>发一个tweet或者在Github上发一个<a href="https://github.com/zenorocha/browser-diet">pull request</a>。</p>
<p>别忘了向你的朋友推荐，让我们一起使Web变得更快。 \o/</p>

  </div>




  </div>
</div>

<div id="footer">
  <div class="center">
    <p><p>Designed by <a href="http://brizabueno.com">Briza Bueno</a> ● Illustrated by <a href="http://www.myextralife.com">Scott Johnson</a></p><p>Created by <a href="http://zenorocha.com">Zeno Rocha</a> ● Brought to you by <a href="http://www.liferay.com">Liferay</a></p></p>
  </div>
</div>

  <script>
    var lang = document.querySelector('#language-picker');
    lang.addEventListener('change', function(e) {
      if (e.target.value === 'en') {
        window.location = '/';
      } else {
        window.location = '/' + e.target.value;
      }
    });
  </script>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-4114546-34', 'auto');
  ga('send', 'pageview');
  </script>

</body>
</html>
