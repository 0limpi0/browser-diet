<p>Korzystanie z natywnych funkcji JavaScript prawie zawsze jest szybsze niż te wykonywanw w jQuery. Z tego powodu, zamiast metody <code>jQuery.each</code> używaj pętli <code>for</code> w JavaScript.</p>
<p>Zwróć jednak uwagę, pomimo, że instrukcja <code>for in</code> jest natywna to w wielu przypadkach wydajnościowo wypada gorzej niż <code>jQuery.each</code>.</p>
<p>Wypróbowana i sprawdzona pętla <code>for</code> daje nam kolejną możliwość przyspieszenia poprzez buforowanie długości przetwarzanej kolekcji.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = a.length; i &lt; len; i++ ) {
    e = a[i];
}
</code></pre>
<p>Używanie odwrotnych pętli <code>while</code> i <code>for</code> stanowi gorący temat w środowisku programistycznym jako najszybsze sposoby iterowania elementów. Niestety są unikane, ze względu na mniejszą czytelność.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-comment">// odwrotna petla while</span>
<span class="hljs-keyword">while</span> ( i-- ) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// odwrotna petla for</span>
<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = array.length; i--; ) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-jquery-each-vs-for-loop">&gt; Wyniki w JSPerf</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#use-for-instead-of-each">Referencje</a></em></p>
