<!doctype html>
<html lang="pl-PL" itemscope itemtype="http://schema.org/CreativeWork">
<head>

  <title>Jak schudnąć (w przeglądarce)</title>

  <!-- Metatags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Ostateczny przewodnik wydajności dla stron internetowych">
  <meta name="keywords" content="front-end, web performance, cache, compress, minify, combine">

  <!-- Schema.org -->
  <meta itemprop="name" content="Jak schudnąć (w przeglądarce)">
  <meta itemprop="url" content="http://browserdiet.com">
  <meta itemprop="image" content="http://browserdiet.com/assets/img/share.jpg">
  <meta itemprop="description" content="Ostateczny przewodnik wydajności dla stron internetowych">

  <!-- Style -->
  <link rel="stylesheet" href="http://browserdiet.com/assets/css/all.min.css?v=50">

  <!-- Fonts -->
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Open+Sans|Pacifico">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="http://browserdiet.com/assets/img/favicon.ico">

</head>

<body class="pl">

  <div id="header">

    <div id="top-bar" class="subtitle">
      <div class="center">

        <div id="language-picker">
          <a href="/pl" class="flags" id="flat-pl">&nbsp;</a>

          <div class="available-languages">
            <a id="flag-en" class="flags" href="http://browserdiet.com/" title="English">English</a>
            <a id="flag-es" class="flags" href="http://browserdiet.com/es/" title="Español">Español</a>
            <a id="flag-pt" class="flags" href="http://browserdiet.com/pt/" title="Português">Português</a>
            <a id="flag-pl" class="flags" href="http://browserdiet.com/pl/" title="Polski">Polski</a>
            <a id="flag-zh" class="flags" href="http://browserdiet.com/zh/" title="中国的">中国的</a>
            <a id="flag-fr" class="flags" href="http://browserdiet.com/fr/" title="Français">Français</a>
            <a id="flag-cs" class="flags" href="http://browserdiet.com/cs/" title="Česky">česky</a>
            <a id="flag-jp" class="flags" href="http://browserdiet.com/jp/" title="日本語">日本語</a>
          </div>
        </div>

        <h3>Ostateczny przewodnik wydajności dla stron internetowych</h3>

      </div>
    </div>

    <a href="https://github.com/zenorocha/browser-diet">
      <img id="github-ribbon" src="http://browserdiet.com/assets/img/github-fork.png" alt="Fork me on GitHub" width="149" height="149">
    </a>

    <div class="center">
      <div class="intro">
        <hgroup class="intro-titles">
          <h1>Jak schudnąć <span>weight</span></h1><h2>w przeglądarce</h2>
        </hgroup>

        <div class="superman">
          <img class="superman-geek" src="http://browserdiet.com/assets/img/superman.png" alt="Superman">
          <img class="superman-raios" src="http://browserdiet.com/assets/img/raios.png" alt="">
        </div>
      </div>

    </div>

    <div id="menu">
      <ul class="center">
        <li><a href="#html">HTML</a></li>
        <li><a href="#css">CSS</a></li>
        <li><a href="#js">JavaScript</a></li>
        <li><a href="#jquery">jQuery</a></li>
        <li><a href="#images">Obrazy</a></li>
        <li><a href="#server">Serwer</a></li>
        <li><a href="#bonus">Bonus</a></li>
      </ul>
    </div>

  </div>

  <div id="content">
    <div class="center">

      
    <div class="article">
      <div class="img-left">
  <img id="geek-17" class="icos-geek" src="http://browserdiet.com/img/17.png" alt="Geek #17" width="199" height="275" />
</div>

<p>Co powiesz, jeśli zebraliśmy razem grono ekspertów, pracujących przy dużych serwisach dla stworzenia przewodnika wydajności?</p>
<p>Jeśli nie jest to jeden, z tych nudnych przewodników dla robotów, tylko coś naprawdę fajnego? <a href="http://www.brizabueno.com/">Briza Bueno</a> <em>(Americanas.com)</em>, <a href="https://github.com/davidsonfellipe">Davidson Fellipe</a> <em>(Globo.com)</em>, <a href="https://github.com/keppelen">Giovanni Keppelen</a> <em>(ex-Peixe Urbano)</em>, <a href="https://github.com/jaydson">Jaydson Gomes</a> <em>(Terra)</em>, <a href="https://github.com/marcelduran">Marcel Duran</a> <em>(Twitter)</em>, <a href="https://github.com/miketaylr">Mike Taylor</a> <em>(Opera)</em>, <a href="https://github.com/mangini">Renato Mangini</a> <em>(Google)</em> and <a href="http://sergiolopes.org">Sérgio Lopes</a> <em>(Caelum)</em> połączyli siły i zebrali najlepsze możliwe referencje?</p>
<p>Właśnie to zrobiliśmy! Pokażemy Ci, że tworzone strony będą jeszcze szybsze.</p>
<p class="project-leader">&mdash; <a href="https://github.com/zenorocha">Zeno Rocha</a>, prowadzący projekt.</p>
    </div>

    <div class="article">
      <h1 id="performance-matters">
  <a class="tip-title" href="#performance-matters">Czy wydajnie oznacza lepiej?</a>
  <a title="Link" class="anchor" href="#performance-matters">∞</a>
</h1>

<div class="line">
  <span class="order">??</span>
  <a title="Edit" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/intro/pl/performance-matters.html.md">✎</a>
</div>

<p>Oczywiście, że tak, przecież dobrze wiesz. Dlaczego zatem robimy ciągle powolne witryny, które prowadzą do złych odczuć użytkowników? Oto praktyczny przewodnik, stworzony przez społeczność, aby strony internetowe były szybsze. Nie traćmy czasu na pokazywanie <a href="https://github.com/zenorocha/browser-diet/wiki/Impact-of-performance">milionów przypadków wydajności</a>. Przejdźmy od razu do rzeczy!</p>
    </div>


      <h2 id="html" class="topics"><span>HTML</span></h2>



  <div class="article" id="article-avoid-inline">
    <h1 id="avoid-inline">
      <a class="tip-title" href="#avoid-inline">Unikaj kodu wbudowanego</a>
      <a title="Link" class="anchor" href="#avoid-inline">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/pl/avoid-inline.html.md">✎</a>
    </div>
    
    <p>Istnieją trzy podstawowe sposoby na dołączanie CSS lub JavaScriptu na twojej stronie:</p>
<p><strong>1) Liniowy:</strong> kod CSS jest zdefiniowany w znaczniku <code>&lt;style&gt;</code>, a kod JavaScript w atrybucie <code>onclick</code> dowolnego znacznika HTML.</p>
<p><strong>2) Wbudowany:</strong> kod CSS jest zdefiniowany w znaczniku <code>&lt;style&gt;</code>, a kod JavaScript w znaczniku <code>&lt;script&gt;</code>.</p>
<p><strong>3) Zewnętrzny:</strong> kod CSS jest ładowany ze znacznika <code>&lt;link&gt;</code>, a kod JavaScript z atrybutu <code>src</code> dla znacznika <code>&lt;script&gt;</code>.</p>
<p>Pierwsze dwie opcje, wprawdzie zmniejszają liczbę żądań HTTP, jednak zwiększają rozmiar samego dokumentu HTML. Taka sytuacja jest użyteczna, kiedy mamy niewielkie zasoby, koszt każdego kolejnego żądania jest znaczący. W tym przypadku, istotne jest przeprowadzenie testów w celu określenia ewentualnego wzrostu szybkości. Konieczne jest określenie celów twojej strony i jej użytkowników. Jeśli planujesz, że twoja strona zostanie odwiedzona tylko jeden raz i nie spodziewasz się powracających użytkowników, przykładowo przy jednorazowych akcjach promocyjnych to kod wbudowany pomaga w zmniejszeniu liczby żądań HTTP.</p>
<p><em>&gt; Unikaj ręcznego tworzenia CSS/JS w środku dokumentu HTML (zalecana jest automatyzacja przy pomocy narzędzi).</em></p>
<p>Trzecia opcja nie tylko poprawia organizację twojego kodu, ale również umożliwia przeglądarce jego przechowywanie w cache. Takie rozwiązanie jest zalecane w większości przypadków, szczególnie przy plikach dużych rozmiarów, gdzie koszt stosowania kodu wbudowanego jest wiekszy.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#avoid-inlineembedded-code">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#avoid-inlineembedded-code">Referencje</a>.</em></p>

  </div>



  <div class="article" id="article-css-on-top-js-on-bottom">
    <h1 id="css-on-top-js-on-bottom">
      <a class="tip-title" href="#css-on-top-js-on-bottom">Style na górze, skrypty na dole</a>
      <a title="Link" class="anchor" href="#css-on-top-js-on-bottom">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/pl/css-on-top-js-on-bottom.html.md">✎</a>
    </div>
    
    <p>Kiedy dołączany arkusze styli w znaczniku <code>&lt;head&gt;</code> pozwalamy na stopniowe generowanie strony, co sprawia wrażenie szybszego ładowania.</p>
<pre class="highlight"><code class="xml"><span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>Browser Diet<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- CSS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"style.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
</code></pre>
<p>Jeśli jednak umieścimy arkusze na końcu kodu strony, całość zostanie wygenerowana bez styli, dopóki pliki CSS nie zostaną pobrane i zastosowane.</p>
<p>Z drugiej strony, jeśli omawiamy JavaScript, bardzo ważne jest umieszczenie skryptów na końcu strony, aby nie blokowały generowania w czasie ładowania i wykonywania.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Lorem ipsum dolor sit amet.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- JS --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"script.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#styles-up-top-scripts-down-bottom">Referencje</a>.</em></p>

  </div>



  <div class="article" id="article-async">
    <h1 id="async">
      <a class="tip-title" href="#async">Spróbuj asynchronicznie</a>
      <a title="Link" class="anchor" href="#async">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/html/pl/async.html.md">✎</a>
    </div>
    
    <p>Najlepszym wyjaśnieniem wpływu podanych atrybutów na lepszą wydajność, będzie zrozumienie tego, co dzieje się bez ich stosowania.</p>
<div class="img-left">
  <img id="geek-20" class="icos-geek" src="http://browserdiet.com/img/20.png" alt="Geek #20" width="118" height="275" />
</div>

<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"example.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>W tym przypadku, strona czeka do momentu, w którym skrypt zostanie całkowicie pobrany, przeanalizowany i wykonany, zanim przejdzie do analizowania i generowania HTML. Takie działanie powoduje dodatkowy narzut na czas ładowania strony. Przeważnie jest to zachowanie nieporządane.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">async</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"example.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Skrypt jest pobierany asynchronicznie, a pozostała część stony jest nadal analizowana. Mamy gwarancję uruchomienia skryptu tuż po zakończeniu jego pobierania.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#try-out-async">Referencje</a></em></p>

  </div>




      <h2 id="css" class="topics"><span>CSS</span></h2>



  <div class="article" id="article-minify-css">
    <h1 id="minify-css">
      <a class="tip-title" href="#minify-css">Minimalizuj swoje arkusze</a>
      <a title="Link" class="anchor" href="#minify-css">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/pl/minify-css.html.md">✎</a>
    </div>
    
    <p>Pisanie komentarzy i używanie wcięć poprawia czytelność kodu i ułatwia jego zarządzaniem.</p>
<pre class="highlight"><code class="css"><span class="hljs-class">.center</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"> <span class="hljs-number">960</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span> auto</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-comment">/* --- Struktura --- */</span>

<span class="hljs-class">.intro</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">100</span>px</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value"> relative</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>Jednak dla przeglądarki nie ma to znaczenia. Z tego powodu pamiętaj zawsze o minimalizowaniu swoich arkuszy CSS poprzez automatyczne narzędzia.</p>
<pre class="highlight"><code class="css"><span class="hljs-class">.center</span><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">width</span>:<span class="hljs-value"><span class="hljs-number">960</span>px</span></span>;<span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">0</span> auto</span></span></span>}<span class="hljs-class">.intro</span><span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"><span class="hljs-number">100</span>px</span></span>;<span class="hljs-rule"><span class="hljs-attribute">position</span>:<span class="hljs-value">relative</span></span></span>}
</code></pre>
<p>Takie golenie rozmiaru pliku, pozwoli w rezultacie na szybsze pobieranie, analizowanie i uruchamianie strony.</p>
<p>Osoby, które używają pre-procesorów jak <a href="http://sass-lang.com/">Sass</a>, <a href="http://lesscss.org/">Less</a> i <a href="http://learnboost.github.com/stylus/">Stylus</a>, mają możliwość ustawienia minimlizowania przetworzonych stylów CSS.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#minify-your-stylesheets">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minify-your-stylesheets">Referencje</a></em></p>

  </div>



  <div class="article" id="article-universal-selector">
    <h1 id="universal-selector">
      <a class="tip-title" href="#universal-selector">Nie używaj selektora uniwersalnego</a>
      <a title="Link" class="anchor" href="#universal-selector">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/pl/universal-selector.html.md">✎</a>
    </div>
    
    <p>Unikaj stosowania selektora ogólnego, ponieważ zmusza przeglądarkę do przeszukiwania <strong>wszystkich</strong> elementów HTML na stronie i stosowania reguł do każdego z nich.</p>
<div class="img-right">
  <img src="http://browserdiet.com/img/4.png" alt="Geek #4" class="icos-geek" width="162" height="275" />
</div>

<pre class="highlight"><code class="css">* <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">margin</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">padding</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">border</span>:<span class="hljs-value"> none</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">text-decoration</span>:<span class="hljs-value"> none</span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">outline</span>:<span class="hljs-value"> <span class="hljs-number">0</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>Taki selektor znajdzie wiele elementów, dla których część reguł nie będzie miało zwyczajnie zastosowania.</p>
<p>Z tego powodu, zalecamy stosowanie gotowych plików CSS Reset lub rozwijanie własnych.</p>
<p><em>&gt; Przydatne narzędzia: <a href="http://yui.yahooapis.com/2.9.0/build/reset/reset-min.css">Yahoo! Reset</a>, <a href="http://necolas.github.com/normalize.css/">Normalize</a> and <a href="http://meyerweb.com/eric/tools/css/reset/">Eric Meyer&#39;s Reset</a>.</em></p>

  </div>



  <div class="article" id="article-combine-css">
    <h1 id="combine-css">
      <a class="tip-title" href="#combine-css">Scalanie wielu plików CSS</a>
      <a title="Link" class="anchor" href="#combine-css">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/pl/combine-css.html.md">✎</a>
    </div>
    
    <p>Kolejna dobra praktyka dla organizacji i obsługi stylów to dzielenie ich na mniejsze moduły.</p>
<div class="img-right">
  <img id="geek-9" class="icos-geek" src="http://browserdiet.com/img/9.png" alt="Geek #9" width="122" height="275" />
</div>

<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"structure.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"banner.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"layout.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"component.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"plugin.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
</code></pre>
<p>Jednak każdy z tych plików wymaga osobnego żądania HTTP (dobrze wiemy, że przeglądarki pobierają równolegle ograniczoną liczbę zasobów).</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"main.css"</span> <span class="hljs-attribute">media</span>=<span class="hljs-value">"all"</span>&gt;</span>
</code></pre>
<p>Połącz swoje pliki CSS. Mniejsza liczba plików, daje w rezultacie mniejszą liczbę żądań i szybsze ładowanie strony.</p>
<p>Chcesz najlepszych wyników? Automatyzacja tego procesu poprzez narzędzia budowania.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#combining-multiple-css-files">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#combining-multiple-css-files">Referencje</a></em></p>

  </div>



  <div class="article" id="article-key-selector">
    <h1 id="key-selector">
      <a class="tip-title" href="#key-selector">Pomyśl o (i przemyśl) swoje selektory</a>
      <a title="Link" class="anchor" href="#key-selector">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/pl/key-selector.html.md">✎</a>
    </div>
    
    <p>Odpowiedni selektor to klucz do twoich wydajnych wyrażeń CSS. Rzadko, koderzy koncentrują się na złożoności reguł, bo nie wiedzą dokładnie jak one działają.</p>
<pre class="highlight"><code class="css"><span class="hljs-tag">header</span> <span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> <span class="hljs-tag">li</span> <span class="hljs-tag">a</span> <span class="hljs-rules">{<span class="hljs-rule">}</span></span>
</code></pre>
<p>Spójrz na powyższe wyrażenie. Co dzieje się kiedy przeglądarka rozpoczyna analizowanie wyrażenia CSS od prawej strony&mdash;w tym przypadku kluczowe jest <code>a</code>. Takie wyrażenie wymaga od przeglądarki sporo pracy. Na początku szukamy wszystkich elementów <code>a</code> w kodzie HTML, później wszystkich elementów <code>li</code>, zawierających <code>a</code>, aż do momentu znalezienia <code>header nav ul li a</code>.</p>
<pre class="highlight"><code class="css"><span class="hljs-tag">header</span> <span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> <span class="hljs-tag">li</span> * <span class="hljs-rules">{ <span class="hljs-comment">/* źle */</span> <span class="hljs-rule">}</span></span>
<span class="hljs-tag">header</span> <span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> <span class="hljs-tag">li</span> <span class="hljs-tag">a</span> <span class="hljs-rules">{ <span class="hljs-comment">/* gorzej */</span> <span class="hljs-rule">}</span></span>
<span class="hljs-tag">nav</span> <span class="hljs-tag">a</span> <span class="hljs-rules">{ <span class="hljs-comment">/* źle */</span> <span class="hljs-rule">}</span></span>
<span class="hljs-tag">nav</span> <span class="hljs-tag">a</span><span class="hljs-class">.nav-link</span> <span class="hljs-rules">{ <span class="hljs-comment">/* lepiej */</span> <span class="hljs-rule">}</span></span>
<span class="hljs-tag">nav</span> <span class="hljs-class">.nav-link</span> <span class="hljs-rules">{ <span class="hljs-comment">/* lepiej */</span> <span class="hljs-rule">}</span></span>
<span class="hljs-class">.nav-link</span> <span class="hljs-rules">{ <span class="hljs-comment">/* lepiej */</span> <span class="hljs-rule">}</span></span>
</code></pre>

  </div>



  <div class="article" id="article-prefer-link-over-import">
    <h1 id="prefer-link-over-import">
      <a class="tip-title" href="#prefer-link-over-import">Preferuj &lt;link&gt; zamiast @import</a>
      <a title="Link" class="anchor" href="#prefer-link-over-import">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/css/pl/prefer-link-over-import.html.md">✎</a>
    </div>
    
    <p>Istnieją dwa sposoby na dołączenie zewnętrznych arkuszy stylów do twojej strony: poprzez znacznik <code>&lt;link&gt;</code>:</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"stylesheet"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"style.css"</span>&gt;</span>
</code></pre>
<p>lub poprzez dyrektywę <code>@import</code> (wewnątrz pliku ze stylami lub w środku znacznika <code>&lt;style&gt;</code>):</p>
<pre class="highlight"><code class="css"><span class="hljs-at_rule">@<span class="hljs-keyword">import</span> <span class="hljs-function">url(<span class="hljs-string">'style.css'</span>)</span></span>;
</code></pre>
<p>Druga opcja, w przypadku stylów zewnętrznych blokuje w przeglądarce pobieranie równoległe, co dalej ogranicza pobieranie kolejnych zasobów.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#prefer--over-import">Referencje</a></em></p>

  </div>




      <h2 id="js" class="topics"><span>JavaScript</span></h2>



  <div class="article" id="article-3rd-party-async">
    <h1 id="3rd-party-async">
      <a class="tip-title" href="#3rd-party-async">Załaduj zewnętrzny kod asynchronicznie</a>
      <a title="Link" class="anchor" href="#3rd-party-async">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/3rd-party-async.html.md">✎</a>
    </div>
    
    <p>Kto nie używał zewnętrznego kodu do osadzenia wideo z YouTube lub przycisku Like/Tweet?</p>
<div class="img-right">
  <img id="geek-46" class="icos-geek" src="http://browserdiet.com/img/46.png" alt="Geek #46" width="158" height="275" />
</div>

<p>Kod zewnętrzny nie zawsze jest sprawnie dostarczany, czasami przez połączenie użytkownika z internetem, innym ze względu na serwer gdzie jest umieszczony, co często stanowi duży problem. Zdarza się, że usługa bywa nawet tymczasowo niedostępna lub zablokowana przez firewall.</p>
<p>Uniknięcie takiej sytuacji jest ważne, ponieważ krytyczne żądanie spowalnia ładowanie strony, a czasami nawet całkowicie je przerywa. Istotne jest ładowanie takiego kodu asynchronicznie lub poprzez <em><a href="https://www.facebook.com/note.php?note_id=10151176218703920">przyjazdne ramki</a></em>.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> script = document.createElement(<span class="hljs-string">'script'</span>),
    scripts = document.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>];
script.async = <span class="hljs-literal">true</span>;
script.src = url;
scripts.parentNode.insertBefore(script, scripts);
</code></pre>
<p>Ewentualnie, jeśli chcesz załadować kilka niezależnych wtyczek, możesz asynchronicznie załadować je z pomocą <a href="https://gist.github.com/zenorocha/5161860">tego skryptu</a>.</p>
<p><em>&gt; <a href="http://www.webpagetest.org/video/view.php?id=111011_4e0708d3caa23b21a798cc01d0fdb7882a735a7d">Wideo</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#load-3rd-party-content-asynchronously">Referencje</a></em></p>

  </div>



  <div class="article" id="article-cache-array-lengths">
    <h1 id="cache-array-lengths">
      <a class="tip-title" href="#cache-array-lengths">Buforuj rozmiar tablicy</a>
      <a title="Link" class="anchor" href="#cache-array-lengths">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/cache-array-lengths.html.md">✎</a>
    </div>
    
    <p>Pętla jest bez wątpienia jednym z najważniejszych elementów związanych z wydajności JavaScript. Optymalizacja logiki wewnątrz pętli jest ważna, ponieważ każda z operacji jest wykonywana wielokrotnie.</p>
<p>Jednym ze sposobów na to jest zapisanie rozmiaru tablicy, która będzie przetwarzana, z tego powodu nie będzie konieczne jego obliczanie przy każdej iteracji.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
  <span class="hljs-comment">// źle - rozmiar jest obliczany 1000 razy</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) {
  <span class="hljs-comment">// dobrze - rozmiar jest obliczny 1 raz i dalej przechowywany</span>
}
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-cache-array-length/">&gt; Wyniki w JSPerf</a></em></p>
<p><strong>&gt; Uwaga:</strong> <em>Chociaż silniki nowoczesnych przeglądarek automatycznie optymalizują ten proces, pamiętaj o dobrych praktykach programistycznych w starszych przeglądarkach.</em></p>
<p>Przetwarzanie kolekcji w HTML jako listy węzłów (<em>NodeList</em>) generowanej przykładowo przez <code>document.getElementsByTagName(&#39;a&#39;)</code> jest krytyczne. Takie kolekcje są traktowane &quot;dynamicznie&quot;, co oznacza automatyczne aktualizowanie w przypadku zmian w elemencie nadrzędnym.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> links = document.getElementsByTagName(<span class="hljs-string">'a'</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; links.length; i++) {
  <span class="hljs-comment">// źle - każda iteracja pętli wymaga przeliczenia listy, czy nie nastąpiła zmiana</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = links.length; i &lt; len; i++) {
  <span class="hljs-comment">// dobrze - rozmiar listy jest uzyskany i przechowywany, później porównywany w kolejnych iteracjach</span>
}

<span class="hljs-comment">// Straszne: przykład pętli nieskończonej</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; links.length; i++) {
  document.body.appendChild(document.createElement(<span class="hljs-string">'a'</span>));
  <span class="hljs-comment">// każda iteracji pętli zwiększa liczbę elementów, warunek końca pętli nie zostanie nigdy osiągnięty</span>
  <span class="hljs-comment">// Byłoby inaczej, gdyby rozmiar listy był przechowywany i używany jako warunek pętli</span>
}
</code></pre>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#cache-array-lengths">Referencje</a></em></p>

  </div>



  <div class="article" id="article-documentwrite">
    <h1 id="documentwrite">
      <a class="tip-title" href="#documentwrite">Unikaj document.write</a>
      <a title="Link" class="anchor" href="#documentwrite">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/documentwrite.html.md">✎</a>
    </div>
    
    <p>Używanie <code>document.write</code> powoduje, że strona jest zależna, a w konsekwencji ponownie ładowana.</p>
<p>Ta (zła) praktyka była zabroniona przez lata, choć dalej istnieją przypadki, kiedy jest wymagana, jak w synchronicznej obsłudze niektorych plików JavaScript.</p>
<p>Przykładowo, <a href="https://github.com/h5bp/html5-boilerplate/">HTML5 Boilerplate</a> używa tej techniki do ładowania jQuery lokalnie, jeśli <em>CDN</em> Google nie odpowiada.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">window.jQuery || document.write(<span class="hljs-string">'&lt;script src="js/vendor/jquery-1.9.0.min.js"&gt;&lt;\/script&gt;'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p><strong>&gt; Uwaga:</strong> <em><code>document.write</code> jest wykonywane w trakcie lub po zdarzeniu <code>window.onload</code> i zastępuje całą zawartość bieżącej strony.</em></p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  window.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    document.write(<span class="hljs-string">'&lt;span&gt;bar&lt;/span&gt;'</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Wynikiem ostatecznej strony będzie <em>bar</em>, a nie <em>foobar</em>, jakbyśmy oczekiwali. To samo dzieje się przy wywołaniu po zdarzeniu <code>window.onload</code>.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    document.write(<span class="hljs-string">'&lt;span&gt;bar&lt;/span&gt;'</span>);
  }, <span class="hljs-number">1000</span>);
  window.onload = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-comment">// ...</span>
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Wynik będzie taki sam, jak w poprzednim przykładzie, jeśli funkcja zaplanowana przez <code>setTimeout</code> zostanie wykonana po zdarzeniu <code>window.onload</code>.</p>
<p><em>&gt; <a href="http://jsbin.com/aqavin/2/quiet">Demo</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#avoid-documentwrite">Referencje</a></em></p>

  </div>



  <div class="article" id="article-repaints-and-reflows">
    <h1 id="repaints-and-reflows">
      <a class="tip-title" href="#repaints-and-reflows">Ograniczaj ponowne malowanie i rysowanie elementów</a>
      <a title="Link" class="anchor" href="#repaints-and-reflows">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/repaints-and-reflows.html.md">✎</a>
    </div>
    
    <p>Ponowne malowanie i rysowanie elementów powstaje w momencie generowania drzewa DOM po zmianie właściwości elementu lub samego elementu.</p>
<p>Ponowne malowanie jest wyzwalane, gdy zmienia się wygląd elementu, ale nie jego układ. Nicole Sullivan opisuje to jako zmianę stylów, na przykład atrybutu <code>background-color</code>.</p>
<p>Ponowne rysowanie jest najbardziej kosztowne, ponieważ jest spowodowane przez zmianę układu strony, na przykład zmianę szerokości elementu.</p>
<p>Nie ma wątpliwości, że zarówno ponowne malowanie i rysowanie elementów powinny być unikane, więc zamiast w ten sposób:</p>
<div class="img-right">
  <img id="geek-55" class="icos-geek" src="http://browserdiet.com/img/55.png" alt="Geek #55" width="163" height="275" />
</div>

<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> div = document.getElementById(<span class="hljs-string">"to-measure"</span>),
    lis = document.getElementsByTagName(<span class="hljs-string">'li'</span>),
    i, len;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = div.offsetWidth + <span class="hljs-string">'px'</span>;
}
</code></pre>
<p>Zróbmy to tak:</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> div = document.getElementById(<span class="hljs-string">"to-measure"</span>),
    lis = document.getElementsByTagName(<span class="hljs-string">'li'</span>),
    widthToSet = div.offsetWidth,
    i, len;

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = lis.length; i &lt; len; i++) {
  lis[i].style.width = widthToSet + <span class="hljs-string">'px'</span>;
}
</code></pre>
<p>Po ustawieniu <code>style.width</code>, przeglądarka ponownie oblicza układ. Przeważnie, zmiany stylów dla wielu elementów powodują pojedyncze rysowanie, dopóki przeglądarka nie musi myśleć, o tym, że aktualizuje ekran. Jednakże, w pierwszym przykładzie potrzebujemy wartości <code>offsetWidth</code>, która jest szerokością elementu, więc przeglądarka potrzebuje przeliczenia układu.</p>
<p>Jeśli potrzebujesz informacji o układzie, pobierz wszystko zanim cokolwiek zmienisz, tak jak w przykładzie drugim.</p>
<p><em>&gt; <a href="http://jsbin.com/aqavin/2/quiet">Demo</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minimize-repaints-and-reflows">Referencje</a></em></p>

  </div>



  <div class="article" id="article-dont-touch-dom">
    <h1 id="dont-touch-dom">
      <a class="tip-title" href="#dont-touch-dom">Unikaj niepotrzebnych manipulacji DOM</a>
      <a title="Link" class="anchor" href="#dont-touch-dom">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/dont-touch-dom.html.md">✎</a>
    </div>
    
    <p>Za każdym razem, gdy niepotrzebnie odwołujesz się do drzewa DOM, umiera Panda.</p>
<p>Poważnie, przeglądanie elementów DOM jest kosztowne. Silniki JavaScriptu są coraz wydajniejsze i szybsze, ale zawsze lepsze jest ograniczenie odwołań do drzewa DOM.</p>
<p>Jednym z najprostszych sposobów optymalizacji jest przechowywanie często używanych elementów DOM. Na przykład, zamiast odpytywania DOM w każdej iteracji pętli, pytamy raz i przechowujemy wynik w zmiennej, dostępnej dla każdej iteracji.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-comment">// bardzo źle!</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  document.getElementById(<span class="hljs-string">"myList"</span>).innerHTML += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}
</code></pre>
<pre class="highlight"><code class="javascript"><span class="hljs-comment">// nieco lepiej :)</span>
<span class="hljs-keyword">var</span> myList = <span class="hljs-string">""</span>;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  myList += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}

document.getElementById(<span class="hljs-string">"myList"</span>).innerHTML = myList;
</code></pre>
<pre class="highlight"><code class="javascript"><span class="hljs-comment">// dużo, *dużo* better :)</span>
<span class="hljs-keyword">var</span> myListHTML = document.getElementById(<span class="hljs-string">"myList"</span>).innerHTML;

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  myListHTML += <span class="hljs-string">"&lt;span&gt;"</span> + i + <span class="hljs-string">"&lt;/span&gt;"</span>;
}
</code></pre>
<p><em>&gt; <a href="http://jsperf.com/browser-diet-dom-manipulation/11">Wuniki w JSPerf</a></em></p>

  </div>



  <div class="article" id="article-minify-js">
    <h1 id="minify-js">
      <a class="tip-title" href="#minify-js">Minimalizuj kod JS</a>
      <a title="Link" class="anchor" href="#minify-js">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/minify-js.html.md">✎</a>
    </div>
    
    <p>Podobnie jak w przypadku CSS, zarządzanie czytelnym kodem jest łatwiejsze, gdy w znajują się w nim komentarze i wcięcia:</p>
<pre class="highlight"><code class="javascript">BrowserDiet.app = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">return</span> {
    bar: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-comment">// do something</span>
    }
  };

};
</code></pre>
<p>Jednak dla przeglądarki jest całkowicie bez znaczenia. Z tego ważne jest minimalizowanie kodu JavaScript przy pomocy automatycznych narzędzi.</p>
<pre class="highlight"><code class="javascript">BrowserDiet.app=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span><span class="hljs-keyword">var</span> a=!<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span>{bar:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>}}}
</code></pre>
<p>Takie golenie rozmiaru pliku, pozwoli w rezultacie na szybsze pobieranie, analizowanie i uruchamianie strony.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#minify-your-script">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#minify-your-script">Referencje</a></em></p>

  </div>



  <div class="article" id="article-combine-js">
    <h1 id="combine-js">
      <a class="tip-title" href="#combine-js">Scalanie wielu plików JS w jeden</a>
      <a title="Link" class="anchor" href="#combine-js">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/js/pl/combine-js.html.md">✎</a>
    </div>
    
    <p>Bardzo dobrym rozwiązaniem dla organizacji i obsługi skryptów jest rozdzielenie ich na osobne moduły.</p>
<div class="img-right">
  <img id="geek-47" class="icos-geek" src="http://browserdiet.com/img/47.png" alt="Geek #47" width="174" height="275" />
</div>

<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"navbar.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"component.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"page.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"framework.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"plugin.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Jednak każdy z tych plików wymaga osobnego żądania HTTP (dobrze wiemy, że przeglądarki pobierają równolegle ograniczoną liczbę zasobów).</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"main.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Połącz swoje pliki JS. Mniejsza liczba plików, daje w rezultacie mniejszą liczbę żądań i szybsze ładowanie strony.</p>
<p>Chcesz najlepszych wyników? Automatyzacja tego procesu poprzez narzędzia budowania.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#combine-multiple-js-files-into-one">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#combine-multiple-js-files-into-one">Referencje</a></em></p>

  </div>




      <h2 id="jquery" class="topics"><span>jQuery</span></h2>



  <div class="article" id="article-latest-version">
    <h1 id="latest-version">
      <a class="tip-title" href="#latest-version">Zawsze korzystaj z najnowszej wersji jQuery</a>
      <a title="Link" class="anchor" href="#latest-version">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/pl/latest-version.html.md">✎</a>
    </div>
    
    <p>Główny zespół jQuery zawsze stara się wnieść poprawki do biblioteki, dzięki lepszej czytelności kodu, nowym funkcjonalnościom i optymalizacji istniejących algorytmów.</p>
<div class="img-right">
  <img id="geek-36" class="icos-geek" src="http://browserdiet.com/img/36.png" alt="Geek #36" width="144" height="275" />
</div>

<p>Z tego powodu, zawsze używaj najnowszej wersji jQuery, która jest dostępna tutaj, jeśli chcesz skopiować skrypt lokalnie:</p>
<pre class="highlight"><code class="xml">http://code.jquery.com/jquery-latest.js
</code></pre>
<p>Jednak <em>nigdy</em> nie używaj tego adresu w znaczniku <code>&lt;script&gt;</code>, ponieważ spowoduje to problemy w przyszłości, kiedy twoja strona automatycznie pobierze aktualne wydanie biblioteki i nie będzie szansy na jej wcześniejsze przetestowanie. Zamiast tego określ dokładnie, której wersji jQuery potrzebujesz.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
<p>Tak jak mądry <a href="/img/new-is-always-better.gif">Barney Stinson</a> mówi, <em>&quot;Nowe jest zawsze lepsze&quot;</em> :P</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#always-use-the-latest-version-of-jquery">Referencje</a></em></p>

  </div>



  <div class="article" id="article-selectors">
    <h1 id="selectors">
      <a class="tip-title" href="#selectors">Selektory</a>
      <a title="Link" class="anchor" href="#selectors">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/pl/selectors.html.md">✎</a>
    </div>
    
    <p>Selektory stanowią jeden z najpoważniejszych problemów przy korzystaniu z jQuery. Istnieje wiele różnych sposobów wyboru elementu z DOM, ale nie wszystkie mają taką samą wydajność, kiedy szukasz według klasy, identyfikatora lub moetod typu <code>find()</code>, czy <code>children()</code>.</p>
<p>Spośród wszystkich dostępnych, wybieranie poprzez ID jest najszybsze, ponieważ opiera się o natywne operacje w DOM:</p>
<pre class="highlight"><code class="javascript">$(<span class="hljs-string">"#foo"</span>);
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-jquery-selectors">&gt; Wyniki w JSPerf</a></em></p>

  </div>



  <div class="article" id="article-use-for-instead-of-each">
    <h1 id="use-for-instead-of-each">
      <a class="tip-title" href="#use-for-instead-of-each">Korzystaj z `for` zamiast `each`</a>
      <a title="Link" class="anchor" href="#use-for-instead-of-each">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/pl/use-for-instead-of-each.html.md">✎</a>
    </div>
    
    <p>Korzystanie z natywnych funkcji JavaScript prawie zawsze jest szybsze niż te wykonywanw w jQuery. Z tego powodu, zamiast metody <code>jQuery.each</code> używaj pętli <code>for</code> w JavaScript.</p>
<p>Zwróć jednak uwagę, pomimo, że instrukcja <code>for in</code> jest natywna to w wielu przypadkach wydajnościowo wypada gorzej niż <code>jQuery.each</code>.</p>
<p>Wypróbowana i sprawdzona pętla <code>for</code> daje nam kolejną możliwość przyspieszenia poprzez buforowanie długości przetwarzanej kolekcji.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = a.length; i &lt; len; i++ ) {
    e = a[i];
}
</code></pre>
<p>Używanie odwrotnych pętli <code>while</code> i <code>for</code> stanowi gorący temat w środowisku programistycznym jako najszybsze sposoby iterowania elementów. Niestety są unikane, ze względu na mniejszą czytelność.</p>
<pre class="highlight"><code class="javascript"><span class="hljs-comment">// odwrotna petla while</span>
<span class="hljs-keyword">while</span> ( i-- ) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// odwrotna petla for</span>
<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = array.length; i--; ) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><em><a href="http://jsperf.com/browser-diet-jquery-each-vs-for-loop">&gt; Wyniki w JSPerf</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#use-for-instead-of-each">Referencje</a></em></p>

  </div>



  <div class="article" id="article-dont-use-jquery">
    <h1 id="dont-use-jquery">
      <a class="tip-title" href="#dont-use-jquery">Nie zawsze korzystaj z jQuery...</a>
      <a title="Link" class="anchor" href="#dont-use-jquery">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/jquery/pl/dont-use-jquery.html.md">✎</a>
    </div>
    
    <p>Czasami czysty JavaScript może być jeszcze prostszy niż jQuery.</p>
<div class="img-right">
  <img id="geek-6" class="icos-geek" src="http://browserdiet.com/img/6.png" alt="Geek #6" width="156" height="275" />
</div>

<p>Rozważmy następujący kod HTML:</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"text"</span>&gt;</span>Zmieńmy treść tego tekstu<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>
<p>Zamiast robić to w taki sposób:</p>
<pre class="highlight"><code class="javascript">$(<span class="hljs-string">'#text'</span>).html(<span class="hljs-string">'Treść zmieniła się'</span>).css({
  backgroundColor: <span class="hljs-string">'red'</span>,
  color: <span class="hljs-string">'yellow'</span>
});
</code></pre>
<p>Użyj samego JavaScriptu:</p>
<pre class="highlight"><code class="javascript"><span class="hljs-keyword">var</span> text = document.getElementById(<span class="hljs-string">'text'</span>);
text.innerHTML = <span class="hljs-string">'Treść zmieniła się'</span>;
text.style.backgroundColor = <span class="hljs-string">'red'</span>;
text.style.color = <span class="hljs-string">'yellow'</span>;
</code></pre>
<p>Tak jest prościej i <strong>o wiele</strong> szybciej.</p>
<p><em>&gt; <a href="http://jsperf.com/jquery-vs-javascript-performance-text">Wyniki w JSPerf</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#dont-use-jquery">Referencje</a></em></p>

  </div>




      <h2 id="images" class="topics"><span>Obrazy</span></h2>



  <div class="article" id="article-sprites">
    <h1 id="sprites">
      <a class="tip-title" href="#sprites">Korzystaj ze sprite'ów CSS</a>
      <a title="Link" class="anchor" href="#sprites">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/pl/sprites.html.md">✎</a>
    </div>
    
    <p>Technika ta polega na grupowaniu różnych obrazów w jednym pliku.</p>
<p><img id="img-sprite" src="http://browserdiet.com/img/sprite-example.jpg" alt="CSS Sprite Example"></p>
<p>A następnie umieszczaniu ich w CSS.</p>
<pre class="highlight"><code class="css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">'mySprite.png'</span>)</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-position</span>:<span class="hljs-value"> -<span class="hljs-number">10</span>px -<span class="hljs-number">10</span>px</span></span>;
<span class="hljs-rule">}</span></span>

<span class="hljs-class">.icon-bar</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">'mySprite.png'</span>)</span></span></span>;
  <span class="hljs-rule"><span class="hljs-attribute">background-position</span>:<span class="hljs-value"> -<span class="hljs-number">5</span>px -<span class="hljs-number">5</span>px</span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>W rezultacie, znacznie zmniejszamy liczbę żądań HTTP i unikamy potencjalnych opóźnień dla innych zasobów naszej strony.</p>
<p>Kiedy używamy <em>ikonek</em>, unikamy pozostawiania zbyt dużej pustej przestrzeni miedzy obrazami. Nie ma to wpływu na rozmiar pliku, ale ma wpływ na zużycie pamięci.</p>
<p>Pomimo szerokiej wiedzy na temat sprite&#39;ów, technika ta nie jest często stosowana&mdash;może, ze względu na brak stosowania narzędzi do automatycznego generowania sprite&#39;ów. Poniżej przedstawiamy listę narzędzi, które okażą się bardzo pomocne.</p>
<p>*&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#use-css-sprites">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#use-css-sprites">Referencje</a></p>

  </div>



  <div class="article" id="article-data-uri">
    <h1 id="data-uri">
      <a class="tip-title" href="#data-uri">Data URI</a>
      <a title="Link" class="anchor" href="#data-uri">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/pl/data-uri.html.md">✎</a>
    </div>
    
    <p>Opisana technika jest alternatywą dla używania &#39;CSS sprites&#39;.</p>
<p>Technika <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">Data-URI</a> jest sposobem na wstawienie danych z określonego adresu. W tym przypadku używamy jej do wstawienia treści jako tła obrazka dla właściwości CSS w celu ograniczenia liczby żądań HTTP potrzebnych do załadowania strony.</p>
<p>Przed:</p>
<pre class="highlight"><code class="css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">'foo.png'</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>Po:</p>
<pre class="highlight"><code class="css"><span class="hljs-class">.icon-foo</span> <span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">background-image</span>:<span class="hljs-value"> <span class="hljs-function">url(<span class="hljs-string">'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAApJREFUCNdjYAAAAAIAAeIhvDMAAAAASUVORK5CYII%3D'</span>)</span></span></span>;
<span class="hljs-rule">}</span></span>
</code></pre>
<p>Wszystkie przeglądarki od IE8 i nowsze wspierają technikę kodowania base64.</p>
<p>Zarówno metoda kodowania base64, jak i CSS sprites wymagają odpowiednich narzędzi do zarządania. Zaletą tej metody jest brak ręcznego pozycjonowania obrazów, które dalej są trzymane w osobnych plikach w czasie rozwoju projektu.</p>
<p>Wadą tego rozwiązania jest rosnący rozmiar HTML/CSS, jeśli mamy duże obrazy. Technika ta nie jest zalecana, jeżeli wynikowy kod HTML/CSS nie jest kompresowany, ponieważ wiele większy rozmiar plików i dłuższy czas pobierania będzie nieadekwatny do zysków ze zmniejszenia liczby żądań HTTP.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#data-uri">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#data-uri">Referencje</a></em></p>

  </div>



  <div class="article" id="article-scale">
    <h1 id="scale">
      <a class="tip-title" href="#scale">Nie skaluj obrazów w znacznikach</a>
      <a title="Link" class="anchor" href="#scale">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/pl/scale.html.md">✎</a>
    </div>
    
    <p>Zawsze określaj rozmiary obrazów poprzez atrybuty <code>width</code> i <code>height</code>. Pomoże to w uniknięciu niepotrzebnego przesuwania elementów podczas generowania strony.</p>
<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">img</span> <span class="hljs-attribute">width</span>=<span class="hljs-value">"100"</span> <span class="hljs-attribute">height</span>=<span class="hljs-value">"100"</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"logo.jpg"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-value">"Logo"</span>&gt;</span>
</code></pre>
<p>Wiedząc, o tym programista Jan K. ma obraz <em>700x700px</em> i decyduje się na jego wyświetlenie w postaci obrazu <em>50x50px</em>.</p>
<p>Co, czy pan programista nie zdaje sobie sprawy, że dziesiątki niepotrzebnych <em>kilobajtów</em> zostaną przesłane przez sieć.</p>
<p>Zawsze miej na uwadze. Możliwość określenia szerokości i wysokości obrazu w HTML nie oznacza, że powienieneś to robić, aby zmniejszyć duże obrazy.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#dont-rescale-images-in-markup">Referencje</a></em></p>

  </div>



  <div class="article" id="article-optimize">
    <h1 id="optimize">
      <a class="tip-title" href="#optimize">Optymalizuj swoje obrazy</a>
      <a title="Link" class="anchor" href="#optimize">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/images/pl/optimize.html.md">✎</a>
    </div>
    
    <p>Pliki obrazów zawierają wiele informacji, ktore są bezużyteczne w sieci. Przykładowe zdjęcie JPEG zawiera metadane <em>Exif</em> z aparatu (jak data, model aparatu, miejsce, itp.). Plik PNG zawiera informacje o kolorach, metadanych, a czasami nawet osadzoną miniaturę. Nic z tego nie jest używane przez przeglądarkę, a tylko przyczynia się do zwiększenia rozmiaru pliku.</p>
<p>Istnieją narzędzia do optymalizacji obrazów, które usuwają te niepotrzebne dane i zmiejszają rozmiar plików bez utraty jakości. Mówimy wtedy o kompresji <em>bezstratnej</em>.</p>
<p>Inny sposób optymalizacji obrazów to kompresja kosztem pogorszenia jakości obrazu. Nazywamy to kompresją <em>stratną</em>. Podczas eksportowania obrazów JPEG, przykładowo wybieramy jakość (liczba między 0 a 100). Myśląc o wydajności, zawsze wybieramy najniższą liczbę z możliwych, gdzie jakość jest do zaakceptowania. Inna powszechna technika stratna to zmniejszenie palety kolorów w formacie PNG lub konwersji plików PNG-24 do formatu PNG-8.</p>
<p>Aby zwiększyć wydaność postrzeganą przez użytkownika należy przekształcić wszystkie pliki JPEG do wersji progresywnych. Progresywne pliki JPEG mają dobrą obsługę w przeglądarkach, są bardzo proste do tworzenia i nie mają znaczącego spadku wydajności. Plusem jest to, że obraz pojawi się wcześniej na stronie (<a href="http://www.patrickmeenan.com/progressive/view.php?img=http://farm2.staticflickr.com/1434/1002257937_021cb46a33_o.jpg">zobacz prezentację</a>).</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/Tools#optimize-your-images">Przydatne narzędzia</a> / <a href="https://github.com/zenorocha/browser-diet/wiki/References#optimize-your-images">Referencje</a></em></p>

  </div>




      <h2 id="server" class="topics"><span>Serwer</span></h2>



  <div class="article" id="article-keep-alive">
    <h1 id="keep-alive">
      <a class="tip-title" href="#keep-alive">Dyrektywa `keep-alive`</a>
      <a title="Link" class="anchor" href="#keep-alive">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/server/pl/keep-alive.html.md">✎</a>
    </div>
    
    <p>Każde żądanie HTTP wymaga ustanowienia połączenia TCP dla komunikacji klienta z serwerem.</p>
<p>Taki proces jest kosztowny i czasochłonny, szczególnie ze względu na &quot;trzy-stopniowy uścisk dłoni&quot;. Ważne jest korzystanie z utworzonych połączeń podczas transportowania danych przez kolejne żądania.</p>
<p>Ustawienie takie określa dyrektywa <code>keep-alive</code>.</p>
<p>Konfiguracja zależy od typu serwera. Na przykład, Apache określa ten stan poprze plik <code>.htaccess</code>:</p>
<pre class="highlight"><code class="apache"><span class="hljs-tag">&lt;IfModule mod_headers.c&gt;</span>
  <span class="hljs-keyword"><span class="hljs-common">Header</span></span> set Connection keep-alive
<span class="hljs-tag">&lt;/IfModule&gt;</span>
</code></pre><p><em>&gt; <a href="https://github.com/cleberdantas/browser-diet/wiki/References#wiki-keep-alive">Referencje</a></em></p>

  </div>



  <div class="article" id="article-cache">
    <h1 id="cache">
      <a class="tip-title" href="#cache">Aktywuj inteligentne buforowanie</a>
      <a title="Link" class="anchor" href="#cache">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/server/pl/cache.html.md">✎</a>
    </div>
    
    <p>Najlepszym sposobem na optymalizację żądań ze strony jest brak żądań, ale to oczywiste. Jednym z najbardziej, użytecznych sposobów uniknięcia niepotrzebnych żądań to buforowanie w pamięci podręcznej przeglądarki. Domyślnie przeglądarka sama decyduje o czsie buforowania plików, ale możliwe jest ustawienie dokładnego czasu przechowywania plików w pamięci podręcznej.</p>
<div class="img-right">
  <img id="geek-15" class="icos-geek" src="http://browserdiet.com/img/15.png" alt="Geek #15" width="141" height="275" />
</div>

<p>Konfiguracja taka jest umieszczona na serwerze. Apache, przykładowo umożliwia ustawienie buforowania w pliku <code>.htaccess</code>:</p>
<pre class="highlight"><code class="mel">ExpiresActive On
ExpiresByType <span class="hljs-keyword">image</span>/gif <span class="hljs-string">"access plus 6 months"</span>
ExpiresByType <span class="hljs-keyword">image</span>/jpeg <span class="hljs-string">"access plus 6 months"</span>
ExpiresByType <span class="hljs-keyword">image</span>/png <span class="hljs-string">"access plus 6 months"</span>
ExpiresByType <span class="hljs-keyword">text</span>/css <span class="hljs-string">"access plus 6 months"</span>
ExpiresByType <span class="hljs-keyword">text</span>/javascript <span class="hljs-string">"access plus 6 months"</span>
ExpiresByType application/javascript <span class="hljs-string">"access plus 6 months"</span>
</code></pre><p>Powyższe instrukcje trzymają obrazy, CSS i JS przez 6 miesięcy&mdash; zaleca się buforowanie ich przynajmniej przez jeden miesiąc. Inne serwery konfigurujemy podobnie.</p>
<p>Jedna ważna rzecz do zapamiętania, jeśli plik jest przechowywany w pamięci podręcznej, przęglądarka nie pobierze więcej noweszego pliku. Wysłanie nowej wersji wymaga zmiany nazwy pliku. Jednym ze sposobów na osiągnięcie tego jest dodawanie wersji lub stempla czasu do nazwy pliku. Przykładowo, zamiast <code>home.js</code> używamy <code>home-v1.js</code>, a w razie aktualizacji nowego <code>home-v2.js</code> i tak dalej.</p>
<p>Inna popularna technika obsługi buforowania to przesyłanie parametru GET w adresie URL: <code>home.js?v=1</code> i <code>home.js?v=2</code>. Podana metoda ma pewną wadę w porównaniu z zmianą nazw plików, ponieważ niektóre serwery proxy ignorują parametry GET, co unimożliwia odświeżenie pamięci podręcznej, gdy tego potrzebujesz.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#enable-smart-caching">Referencje</a></em></p>

  </div>



  <div class="article" id="article-gzip">
    <h1 id="gzip">
      <a class="tip-title" href="#gzip">GZIP</a>
      <a title="Link" class="anchor" href="#gzip">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/server/pl/gzip.html.md">✎</a>
    </div>
    
    <p>Znaczna część zawartości strony to prosty tekst (HTML, CSS, JavaScript, JSON, XML, itd.). Włączenie kompresji GZIP na poziomie serwera dla tego rodzaju treści to bardzo dobra praktyka.</p>
<p>GZIP kopresuje dane na serwerze przed wysłaniem ich przez sieć do przeflądarki użytkownika, która dekoduje dane w locie. To tak jak skompresowanie pliku przed wysłaniem do kogoś, aby go zmniejszyć. Wszystkie nowoczesne przeglądarki i serwerzy obsługują GZIP.</p>
<p>Konfiguracja jest ustawiona na serwerze. Przykładowo, Apache udostępnia włączenie GZIP dla wybranych typów w pliku <code>.htaccess</code>:</p>
<pre class="highlight"><code class="applescript">AddOutputFilterByType DEFLATE <span class="hljs-type">text</span>/html
AddOutputFilterByType DEFLATE <span class="hljs-type">text</span>/plain
AddOutputFilterByType DEFLATE <span class="hljs-type">text</span>/xml
AddOutputFilterByType DEFLATE <span class="hljs-type">text</span>/css
AddOutputFilterByType DEFLATE <span class="hljs-type">application</span>/javascript
</code></pre><p>Wszystkie popularne serwery konfiguruje się równie łatwo (sprawdź dokumentacji swojego!) i jest to jeden z najbardziej skutecznych sposobów poprawy wydajności strony.</p>
<p><em>&gt; <a href="https://github.com/zenorocha/browser-diet/wiki/References#gzip">Referencje</a></em></p>

  </div>




      <h2 id="bonus" class="topics"><span>Bonus</span></h2>



  <div class="article" id="article-tools">
    <h1 id="tools">
      <a class="tip-title" href="#tools">Narzędzia diagnostyczne: twój najlepszy przyjaciel</a>
      <a title="Link" class="anchor" href="#tools">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/bonus/pl/tools.html.md">✎</a>
    </div>
    
    <div class="img-left">
  <img id="geek-43" class="icos-geek" src="http://browserdiet.com/img/43.png" alt="Geek #43" width="157" height="275" />
</div>

<p>Jeśli chcesz dołączyć do świata wydajności internetowej, kluczowe będzie zainstalowanie wtyczek <a href="http://yslow.org/">YSlow</a> i <a href="https://developers.google.com/speed/pagespeed/insights_extensions">PageSpeed</a> w twojej przeglądarce&mdash;od teraz będą twoimi najlepszymi przyjaciółmi.</p>
<p>Albo, jeśli wolisz narzędzia online, odwiedź strony <a href="http://www.webpagetest.org/">WebPageTest</a>, <a href="http://httparchive.org/">HTTP Archive</a> lub <a href="http://pagespeed.googlelabs.com/">PageSpeed</a>.</p>
<p>W zasadzie każde z nich po analizie wydajności twojej strony stworzy raport, który połączony z bezcennymi radami pomoże w rozwiązaniu ewentualnych problemów.</p>

  </div>



  <div class="article" id="article-bye">
    <h1 id="bye">
      <a class="tip-title" href="#bye">To wszystko na dziś!</a>
      <a title="Link" class="anchor" href="#bye">∞</a>
    </h1>
    
    <div class="line">
      <span class="order rule-counter"></span>
      <a title="Edytuj" class="edit" href="https://github.com/zenorocha/browser-diet/edit/master/src/documents/bonus/pl/bye.html.md">✎</a>
    </div>
    
    <div class="img-right">
  <img id="geek-31" src="http://browserdiet.com/img/31.png" alt="Geek #31" width="162" height="275" />
</div>

<p>Mamy nadzieję, że po przeczytaniu tego poradnika Twoja strona będzie lepsza. :)</p>
<p>Pamiętaj, jak ze wszystkim w życiu, <a href="http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html">nie ma czegoś takiego jak srebrna kula</a>. Kwestia wydajności twojej aplikacji jest opłacalna, ale nie powinna być jedynym kierunkiem rozwoju&mdash;poprostu oceniasz czy spodziewane korzyści są warte zachodu.</p>
<p>Chcesz dowiedzieć się więcej? Sprawdź <a href="https://github.com/zenorocha/browser-diet/wiki/References">odnośniki</a> wykorzystane przy pisaniu tego przewodnika.</p>
<p>Jakieś sugestie? Wyślij tweeta do <a href="http://twitter.com/zenorocha/">@zenorocha</a> lub <a href="https://github.com/zenorocha/browser-diet">wywołaj żądanie</a> na Githubie.</p>
<p>Nie zapomnij podzielić się z przyjaciółmi, uczyńmy internet szybszym dla wszystkich. \o/</p>

  </div>




    </div>
  </div>

  <div id="footer">
    <div class="center">
      <p>Rozwijane przez <em>Zeno Rocha</em> ● Zaprojektowane przez <em>Briza Bueno</em> ● Ilustracje wykonane przez <em>Scott Johnson</em></p>
    </div>
  </div>

  <!-- <a title="Do góry" id="top" href="#top-bar">
    <img src="http://browserdiet.com/assets/img/top.png" alt="Do góry" width="64" height="64">
  </a> -->

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-4114546-34']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>

</body>
</html>
